非常好的問題，而且這就是薪資系統會爆炸的核心：

> **資料應該寫死在程式裡（list/enum），還是外部化成 JSON，再載入成物件？**

我先給你一句總結，再給你工程上最漂亮的做法：

---

# ✅結論（你這個 Louvois demo 最適合）

## **軍階/軍種 → enum**

## **人員/單位/任務 → JSON 或 YAML**

## **規則本身 → JSON（必須外部化）**

也就是：

| 類型                     | 變動頻率    | 最佳形式             |
| ---------------------- | ------- | ---------------- |
| 軍種（Army/Navy/AirForce） | 幾乎不變    | ✅ Enum           |
| 軍階（Lieutenant…）        | 很少變     | ✅ Enum           |
| 單位（Unit 101, CyberCmd） | 常變      | ✅ JSON           |
| 人員資料（Employee）         | 非常常變    | ✅ JSON/DB        |
| 派遣任務資料                 | 常變      | ✅ JSON           |
| 薪資規則（R001…）            | 最常變、最危險 | ✅ JSON Rule File |

---

# ✅為什麼不能全部用 Enum 或 List？

### 寫死在程式裡：

```python
employees = [
  {"id": "E001", "rank": "Captain"}
]
```

缺點：

* 改一個人要改程式碼
* 無法做測試資料版本管理
* 無法模擬真實整合情境
* 最重要：

> Louvois 災難就是資料與規則散落在不同系統

所以你反而要做「外部資料化」來模擬真實感。

---

# ✅正確分層：Domain 固定 vs Business 可變

薪資系統裡有兩種東西：

---

## ① 固定 Domain（適合 Enum）

### 軍種

```python
from enum import Enum

class Branch(Enum):
    ARMY = "Army"
    NAVY = "Navy"
    AIR_FORCE = "AirForce"
```

### 軍階

```python
class Rank(Enum):
    PRIVATE = "Private"
    SERGEANT = "Sergeant"
    CAPTAIN = "Captain"
    MAJOR = "Major"
```

✅好處：

* 型別安全
* IDE autocomplete
* 減少錯字
* 適合用在 rule 條件

---

## ② 可變 Business Data（適合 JSON）

### 人員資料 employees.json

```json
[
  {
    "id": "E001",
    "name": "Jean Dupont",
    "branch": "Army",
    "rank": "Captain",
    "unit": "CyberCommand"
  },
  {
    "id": "E002",
    "name": "Marie Leclerc",
    "branch": "Navy",
    "rank": "Lieutenant",
    "unit": "FleetOps"
  }
]
```

✅好處：

* 可以一直加測試資料
* 不用改 code
* 可以模擬「人事系統匯入」

---

# ✅啟動時讀 JSON → 轉成物件

你可以寫：

## domain model

```python
from dataclasses import dataclass
from enum import Enum

class Branch(Enum):
    ARMY = "Army"
    NAVY = "Navy"
    AIR_FORCE = "AirForce"

class Rank(Enum):
    CAPTAIN = "Captain"
    MAJOR = "Major"

@dataclass
class Employee:
    id: str
    name: str
    branch: Branch
    rank: Rank
    unit: str
```

---

## loader

```python
import json

def load_employees(path="data/employees.json"):
    with open(path) as f:
        raw = json.load(f)

    employees = []
    for e in raw:
        emp = Employee(
            id=e["id"],
            name=e["name"],
            branch=Branch(e["branch"]),
            rank=Rank(e["rank"]),
            unit=e["unit"]
        )
        employees.append(emp)

    return employees
```

---

## main.py

```python
employees = load_employees()

print(employees[0])
```

輸出：

```
Employee(id='E001', branch=<Branch.ARMY>, rank=<Rank.CAPTAIN>)
```

✅你就做到：

* 外部資料
* 內部強型別
* 真實薪資系統風格

---

# ✅你問的三種方案比較（最清楚）

| 方法            | 適合誰          | 缺點             |
| ------------- | ------------ | -------------- |
| List 寫死在程式    | Demo 10 分鐘   | 改資料要改 code     |
| Enum          | 軍階軍種這種「固定分類」 | 不適合放人員資料       |
| JSON → object | 最像 ERP 系統    | 需要 loader，但很值得 |

---

# ✅最佳實務：你專案的推薦配置

```
payroll_demo/
├── domain/
│   ├── enums.py        ← Branch, Rank
│   ├── models.py       ← Employee dataclass
├── data/
│   ├── employees.json
│   ├── units.json
├── rules/
│   ├── rules.json      ← 核心
├── payroll/
│   ├── engine.py
│   ├── loader.py
└── main.py
```

這是最乾淨、最 Louvois 教學價值高的架構。

---

# ✅下一步我非常建議你做的最小範例

我可以直接下一步幫你生成：

* employees.json（10 人）
* rank enum（8 階）
* loader.py
* CLI 指令：

```bash
python main.py --employee E001 --month 2026-01 --explain
```

你想先從：

A. 人員資料 + 軍階軍種 enum
B. rules.json 規則引擎
C. explain trace 系統

哪個開始？
